#!/bin/sh
set -o errexit
set -o nounset
LIB=$(cd $(dirname $0); pwd)

PRODUCTION_REPO=$1
FIXED_REPO=$2
SVN_ROOT=$3
MODULE=$4
BRANCH_MAP=$5

WORK_DIR=/var/tmp/recover-broken-git
mkdir -p $WORK_DIR
cd $WORK_DIR

MODULE_DIR=${PRODUCTION_REPO##*/}

if [ ! -d $MODULE_DIR ]; then
    git clone --bare $PRODUCTION_REPO $MODULE_DIR
fi
cd $MODULE_DIR
git fetch origin

git remote | grep fixed || git remote add fixed $FIXED_REPO
git fetch fixed

# (cut: cut the columns with the * marker of the current branch)
BRANCHES=`git branch | cut -c3-`
#BRANCHES="master Code-11-SP2"

# $1 SVN URL (ROOT/BRANCH/MODULE)
# $2 git repo as a local directory
# $3 git branch
# $4 name; optional, basename of svn url is used
# result: diff sent to stdout, working dirs are removed
svn_git_compare() {
   local SVNREPO="$1"
   local GITREPO="$2"
   local GITBRANCH="$3"
   local NAME="${4-${SVNREPO##*/}}"

   DIR=`mktemp -d`
   pushd $DIR >/dev/null

   svn export --quiet --ignore-keywords $SVNREPO $NAME-svn

   git archive --format=tar --prefix $NAME-git/ \
       --remote=$GITREPO $GITBRANCH \
       | tar xf -

   SAME=true
   # git-diff better than plain diff
   git --no-pager diff $NAME-svn $NAME-git | tee $DIR/repo.diff
   # non-empty diff => fail
   test -s $DIR/repo.diff && SAME=false

   popd >/dev/null
   rm -rf $DIR
   $SAME # can stop everything
}

svn_branch_from_git_branch() {
    local BRANCH=$1
    local SVN_BRANCH

    SVN_BRANCH=`sed -n "s/^$BRANCH[[:space:]]\+\([^[:space:]]*\).*/\1/;T;p;q" $BRANCH_MAP`

    if [ -n "$SVN_BRANCH" ]; then
        SVN_BRANCH=branches/$SVN_BRANCH
    elif [ $BRANCH = master  ]; then
        SVN_BRANCH=trunk
    else
        SVN_BRANCH=branches/$BRANCH
    fi
    echo $SVN_BRANCH
}

# $1 git branch
last_commit_in_svn() {
    git rev-list -n1 --grep="svn path=/.*; revision=" $1
}

RECOVERY_NEEDED=false

for BRANCH in $BRANCHES; do
    SVN_BRANCH=`svn_branch_from_git_branch $BRANCH`
    SVN_TREE=$SVN_ROOT/$SVN_BRANCH/$MODULE

    # ensure that we have a tag pointing to the last commit in SVN
    LAST_COMMIT_IN_SVN=$(git rev-list -n1 svn/$BRANCH -- || true)
    if [ -z "$LAST_COMMIT_IN_SVN" ]; then
        LAST_COMMIT_IN_SVN=$(last_commit_in_svn $BRANCH)
        git tag svn/$BRANCH $LAST_COMMIT_IN_SVN
    fi

    # compare the production repo. if there is no difference we can continue
    # with the next branch
    if svn_git_compare "$SVN_TREE" `pwd` svn/$BRANCH; then
        echo $MODULE/$BRANCH is OK already
        continue
    fi
    echo $MODULE/$BRANCH needs recovery
    # but even if only one tree is different,
    # the history of all child trees changes
    RECOVERY_NEEDED=true
done

if ! $RECOVERY_NEEDED; then
    echo $MODULE is ALL OK already
    exit 0
fi

echo "GONNA FIX, HOLD ON TO YOUR HAT"

for BRANCH in $BRANCHES; do
    SVN_BRANCH=`svn_branch_from_git_branch $BRANCH`
    SVN_TREE=$SVN_ROOT/$SVN_BRANCH/$MODULE

    # there is a difference.
    # compare that the fixed repo has no difference
    svn_git_compare "$SVN_TREE" `pwd` `last_commit_in_svn fixed/$BRANCH`

    # next: rename  branch refs
    # rename tag refs
    # rebase

    # push. failsafe? iterate?
done
